<script>
    // Main script

    const authManager = {
        session: null,
        accessToken: null,
        user: null,

        async initialize() {
            if (!window.supabase) {
                console.error("Supabase client (window.supabase) not available. Auth cannot be initialized.");
                showError("Authentication service is unavailable. Please try again later.");
                const storyCategoryScreen = document.getElementById('storyCategoryScreen');
                if (storyCategoryScreen) {
                     storyCategoryScreen.innerHTML = '<p class="text-red-500 text-center p-8 text-lg">Critical Error: Authentication service did not load. Please refresh or contact support.</p>';
                }
                const lessonTopicScreen = document.getElementById('lessonTopicScreen');
                if (lessonTopicScreen) lessonTopicScreen.classList.add('hidden');
                const storyContainer = document.getElementById('storyContainer');
                if (storyContainer) storyContainer.classList.add('hidden');
                hideLoader();
                return false; 
            }

            try {
                const { data, error } = await window.supabase.auth.getSession();
                if (error) {
                    console.error("Error getting session:", error.message);
                    window.location.href = '/'; 
                    return false;
                }
                if (!data.session) {
                    console.log("No active session, redirecting to login.");
                    window.location.href = '/'; 
                    return false;
                }
                
                this.session = data.session;
                this.accessToken = data.session.access_token;
                this.user = data.session.user;
                console.log("Session retrieved on /select:", this.session);
                this.updateUserStatusUI();

                window.supabase.auth.onAuthStateChange((event, session) => {
                    console.log('Auth event on /select page:', event, session);
                    if (event === 'SIGNED_OUT') {
                        authManager.clearSessionAndRedirect();
                    } else if (event === 'TOKEN_REFRESHED' || event === 'USER_UPDATED') {
                        this.session = session;
                        this.accessToken = session ? session.access_token : null;
                        this.user = session ? session.user : null;
                        this.updateUserStatusUI();
                    }
                });
                return true; 
            } catch (e) {
                console.error("Exception during auth initialization:", e);
                showError("An error occurred during authentication setup.");
                window.location.href = '/'; 
                return false;
            }
        },

        updateUserStatusUI() {
            const userStatusEl = document.getElementById('user-status');
            const logoutButton = document.getElementById('logout-button');
            if (userStatusEl && logoutButton) {
                if (this.user) {
                    let displayName = "Guest";
                    if (this.user.is_anonymous === false && this.user.email) {
                        displayName = this.user.email;
                    } else if (this.user.is_anonymous === true && this.user.id) {
                        displayName = `Guest (${this.user.id.substring(0,8)}...)`;
                    }
                    userStatusEl.textContent = `Logged in as: ${displayName}`;
                    logoutButton.classList.remove('hidden');
                } else {
                    userStatusEl.textContent = 'Not logged in.';
                    logoutButton.classList.add('hidden');
                }
            }
        },

        async handleLogout() {
            if (!window.supabase) {
                console.error("Supabase client not available for logout.");
                return;
            }
            showLoader();
            const { error } = await window.supabase.auth.signOut();
            if (error) {
                console.error('Error logging out:', error);
                alert('Error logging out: ' + error.message);
                hideLoader();
            }
            // onAuthStateChange (event === 'SIGNED_OUT') handles redirect.
        },
        
        clearSessionAndRedirect() {
            this.session = null;
            this.accessToken = null;
            this.user = null;
            console.log("Session cleared, redirecting to login page.");
            window.location.href = '/';
        }
    };
    
    // State and WebSocket Management
    class AdventureStateManager {
        constructor() {
            this.STORAGE_KEY = 'adventure_state';
            this.CLIENT_UUID_KEY = 'learning_odyssey_user_uuid';
            this.ensureClientUuid();
        }

        saveState(state) {
            // Ensure client_uuid is stored in state metadata
            if (!state.metadata) {
                state.metadata = {};
            }
            state.metadata.client_uuid = this.getClientUuid();
            
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(state));
        }

        loadState() {
            const saved = localStorage.getItem(this.STORAGE_KEY);
            return saved ? JSON.parse(saved) : null;
        }

        clearState() {
            localStorage.removeItem(this.STORAGE_KEY);
            // Note: We don't clear the client UUID as it's used for persistence
        }
        
        ensureClientUuid() {
            // Generate a UUID if one doesn't exist
            if (!localStorage.getItem(this.CLIENT_UUID_KEY)) {
                // Use crypto.randomUUID() if available (modern browsers)
                const uuid = crypto.randomUUID ? 
                    crypto.randomUUID() : 
                    this.generateFallbackUuid();
                    
                localStorage.setItem(this.CLIENT_UUID_KEY, uuid);
                console.log('Generated new client UUID for persistence');
            }
        }
        
        getClientUuid() {
            return localStorage.getItem(this.CLIENT_UUID_KEY);
        }
        
        // Fallback UUID generator for older browsers
        generateFallbackUuid() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
    }

    class WebSocketManager {
        constructor() {
            this.stateManager = new AdventureStateManager();
            this.connection = null;
            this.reconnectAttempts = 0;
            this.maxReconnectAttempts = 5;
            this.baseDelay = 1000; // 1 second
            this.maxDelay = 30000; // 30 seconds
            this.adventureId = null; // Store adventure_id for persistence
            this.adventureIdToResume = null; // For resuming specific adventure from modal
        }

        getWebSocketUrl() {
            console.log('[FrontendWS Log 1.2] getWebSocketUrl called.');
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const storyCategoryEl = document.getElementById('storyCategory');
            const lessonTopicEl = document.getElementById('lessonTopic');
            
            // These might not be available if resuming directly via adventureIdToResume
            const storyCategory = storyCategoryEl ? storyCategoryEl.value : 'unknown';
            const lessonTopic = lessonTopicEl ? lessonTopicEl.value : 'unknown';
            
            const clientUuid = this.stateManager.getClientUuid(); 
            
            const encodedStoryCategory = encodeURIComponent(storyCategory);
            const encodedLessonTopic = encodeURIComponent(lessonTopic);
            const encodedClientUuid = encodeURIComponent(clientUuid);

            let url = `${protocol}//${window.location.host}/ws/story/${encodedStoryCategory}/${encodedLessonTopic}?client_uuid=${encodedClientUuid}`;
            
            if (authManager.accessToken) {
                console.log('[FrontendWS Log 4] Token will be appended to URL.');
                url += `&token=${encodeURIComponent(authManager.accessToken)}`;
            } else {
                console.warn('[FrontendWS Log 5] No token found, proceeding without token for WebSocket.');
            }

            // If resuming a specific adventure, add its ID to the URL
            // The backend will prioritize this over category/topic for loading state.
            if (this.adventureIdToResume) {
                url += `&resume_adventure_id=${encodeURIComponent(this.adventureIdToResume)}`;
                console.log(`[FrontendWS Log 5.1] Appending resume_adventure_id: ${this.adventureIdToResume}`);
            }

            console.log('[FrontendWS Log 6] Final WebSocket URL:', url);
            return url;
        }
        
        setAdventureId(id) {
            this.adventureId = id;
            console.log(`Set adventure_id: ${id} for persistence`);
        }
        
        getAdventureId() {
            return this.adventureId;
        }

        async handleDisconnect() {
            if (this.connection?.readyState === WebSocket.CLOSED) {
                await this.reconnect();
            }
        }

        calculateBackoff() {
            return Math.min(
                this.baseDelay * Math.pow(2, this.reconnectAttempts),
                this.maxDelay
            );
        }

        async reconnect() {
            if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                appendStoryText('\n\nUnable to reconnect after multiple attempts. Please refresh the page.');
                return;
            }

            const savedState = this.stateManager.loadState();
            if (!savedState) {
                appendStoryText('\n\nUnable to recover story state. Please refresh the page.');
                return;
            }

            const delay = this.calculateBackoff();
            await new Promise(resolve => setTimeout(resolve, delay));

            const websocketUrl = this.getWebSocketUrl();
            console.log("[WebSocketManager.reconnect] Attempting to connect to WebSocket URL:", websocketUrl); 
            try {
                this.connection = new WebSocket(websocketUrl);
                console.log("[WebSocketManager.reconnect] WebSocket object created:", this.connection); 
                this.setupConnectionHandlers();
                this.reconnectAttempts++;
            } catch (e) {
                console.error("[WebSocketManager.reconnect] Error creating WebSocket:", e); 
                hideLoader();
            }
        }

        setupConnectionHandlers() {
            const savedState = this.stateManager.loadState();

            this.connection.onopen = () => {
                console.log('[FrontendWS Log 9] WebSocket connection opened.');
                this.reconnectAttempts = 0;

                if (this.adventureIdToResume) {
                    console.log(`[FrontendWS] Resuming specific adventure ID: ${this.adventureIdToResume}. Sending resume request.`);
                    // Server will load state based on this ID. No need to send client-side state.
                    // The backend WebSocket handler needs to be updated to look for `resume_adventure_id`
                    // in the query params and use it to load state via StateStorageService.get_state().
                    // For now, we'll send a specific message type.
                    // OR, the backend can pick up resume_adventure_id from the URL query params directly.
                    // Let's assume backend handles resume_adventure_id from URL for now.
                    // We still need to send a 'start' or 'resume' signal.
                    this.connection.send(JSON.stringify({
                        choice: 'resume_specific_adventure', // A new choice type for clarity
                        adventure_id_to_resume: this.adventureIdToResume 
                        // state: null // No client state needed if server loads by ID
                    }));
                    // Clear it after sending so normal flow resumes if connection drops and reconnects
                    // this.adventureIdToResume = null; // Reconsider this, might be needed for reconnects
                } else if (savedState) {
                    const currentChapter = savedState.chapters.length;
                    updateProgress(currentChapter + 1, savedState.story_length);
                    this.connection.send(JSON.stringify({
                        state: savedState,
                        choice: 'start'
                    }));
                } else {
                    const storyCategoryEl = document.getElementById('storyCategory');
                    const lessonTopicEl = document.getElementById('lessonTopic');
                    const initialState = manageState('initialize', {
                        storyCategory: storyCategoryEl ? storyCategoryEl.value : '',
                        lessonTopic: lessonTopicEl ? lessonTopicEl.value : ''
                    });
                    this.connection.send(JSON.stringify({
                        state: initialState,
                        choice: 'start'
                    }));
                }
            };

            this.connection.onclose = (event) => {
                console.log(`[FrontendWS Log 11] WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}, Clean: ${event.wasClean}`);
                hideLoader();
                if (!event.wasClean) {
                    console.error('WebSocket connection died');
                    this.handleDisconnect();
                }
            };

            this.connection.onerror = (error) => {
                console.error('[FrontendWS Log 10] WebSocket Error: ', error);
                hideLoader();
            };

            this.connection.onmessage = handleMessage;
        }
    }

    // Global instances
    const stateManager = new AdventureStateManager();
    const wsManager = new WebSocketManager();
    let storyWebSocket;
    let selectedCategory = '';
    let selectedLessonTopic = '';
    const totalCategories = parseInt("{{ story_categories|length }}");
    const totalLessonTopics = parseInt("{{ lesson_topics|length }}");

    // --- Navigation Functions ---
    // Function to show error messages
    function showError(message) {
        const toast = document.createElement('div');
        toast.className = 'toast-notification';
        toast.textContent = message;
        document.body.appendChild(toast);
        
        // Remove after 3 seconds
        setTimeout(() => {
            toast.classList.add('hide');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    function goToLessonTopicScreen() {
        if (!selectedCategory) {
            showError('Please select a story category to continue');
            return;
        }
        // Add hidden class to trigger transition
        document.getElementById('storyCategoryScreen').classList.add('hidden');
        // Remove hidden class to trigger transition
        document.getElementById('lessonTopicScreen').classList.remove('hidden');
        
        // Initialize the lesson carousel with our Carousel class
        window.lessonCarousel = new Carousel({
            elementId: 'lessonCarousel',
            itemCount: totalLessonTopics,
            dataAttribute: 'topic',
            inputId: 'lessonTopic',
            onSelect: (topic) => {
                selectedLessonTopic = topic;
            }
        });
        
        // Update the keyboard navigation to include the lesson carousel
        setupCarouselKeyboardNavigation([window.categoryCarousel, window.lessonCarousel]);
        
        // Fix mobile-specific active card scaling if needed
        if (window.innerWidth <= 768) {
            window.lessonCarousel.fixMobileActiveCardScaling();
        }
    }

function startAdventure() {
    console.log('[FrontendWS Log 0] startAdventure called. Category:', selectedCategory, 'Topic:', selectedLessonTopic);
    // Validate both inputs
    if (!selectedCategory) {
        showError('Please select a story category to continue');
        return;
    }
    
    if (!selectedLessonTopic) {
        showError('Please select a lesson topic to begin');
        return;
    }
    
    // Initialize state with selected options
    manageState('initialize', {
        storyCategory: selectedCategory,
        lessonTopic: selectedLessonTopic
    });

    // Update UI - add hidden class to trigger transitions
    document.getElementById('lessonTopicScreen').classList.add('hidden');
    document.getElementById('introText').classList.add('hidden');
    // Remove hidden class to trigger transition
    document.getElementById('storyContainer').classList.remove('hidden');

    // Start the adventure
    showLoader();
    console.log('[FrontendWS Log 1] Before calling initWebSocket() in startAdventure.');
    initWebSocket();
}

    // Initialize carousels on page load
    window.addEventListener('load', () => {
        // Create category carousel
        window.categoryCarousel = new Carousel({
            elementId: 'categoryCarousel',
            itemCount: totalCategories,
            dataAttribute: 'category',
            inputId: 'storyCategory',
            onSelect: (categoryId) => {
                selectedCategory = categoryId;
            }
        });
        
        // Set up global keyboard navigation
        setupCarouselKeyboardNavigation([window.categoryCarousel]);
    });

    // Initialize marked.js with custom options
    marked.setOptions({
        breaks: true,  // Enable line breaks
        gfm: true,    // Enable GitHub Flavored Markdown
        sanitize: false // Allow HTML in the markdown
    });

    let streamBuffer = '';  // Buffer for accumulating streamed text
    let renderTimeout = null;  // Timeout for debounced rendering

    // --- Utility Functions ---
    function showLoader() {
        console.log('Showing loader...');
        const overlay = document.getElementById('loaderOverlay');
        if (!overlay) {
            console.error('Loader overlay element not found!');
            return;
        }
        
        // Force display to ensure it's visible
        overlay.style.display = 'flex';
        overlay.classList.remove('hidden');
        
        // Use setTimeout to ensure the transition works
        setTimeout(() => {
            overlay.classList.add('active');
            console.log('Loader activated');
        }, 0);
    }

    function hideLoader() {
        console.log('Hiding loader...');
        const overlay = document.getElementById('loaderOverlay');
        if (!overlay) {
            console.error('Loader overlay element not found!');
            return;
        }
        
        overlay.classList.remove('active');
        
        // Wait for transition to complete before hiding
        setTimeout(() => {
            overlay.classList.add('hidden');
            console.log('Loader hidden');
        }, 300);
    }
    
    // Function to update progress display
    function updateProgress(currentChapter, totalChapters) {
        document.getElementById('current-chapter').textContent = currentChapter;
        document.getElementById('total-chapters').textContent = totalChapters;
        
        // Dispatch event for new chapter loaded (for font size manager)
        document.dispatchEvent(new CustomEvent('newChapterLoaded'));
    }

    // --- WebSocket Functions ---

    function initWebSocket() {
        showLoader();
        console.log('[FrontendWS Log 1.1] initWebSocket called.');
        if (!authManager || !authManager.accessToken) {
            console.warn('[FrontendWS Log 2] In initWebSocket: AuthManager or AccessToken is missing initially.');
        } else {
            console.log('[FrontendWS Log 3] In initWebSocket: AccessToken found initially:', authManager.accessToken ? 'Exists' : 'MISSING');
        }

        const websocketUrl = wsManager.getWebSocketUrl(); 

        try {
            console.log('[FrontendWS Log 7] About to call "new WebSocket()" in initWebSocket.');
            storyWebSocket = new WebSocket(websocketUrl);
            console.log("[FrontendWS Log 8] WebSocket object created:", storyWebSocket); 
            wsManager.connection = storyWebSocket;
            wsManager.setupConnectionHandlers(); // This will set onopen, onclose, onerror, onmessage
        } catch (e) {
            console.error("[FrontendWS Log 12] CRITICAL ERROR instantiating WebSocket:", e); 
            hideLoader(); // Hide loader if WebSocket creation fails
        }

        // Initialize with a new state or restore existing
        const savedState = stateManager.loadState();
        if (savedState) {
            // Restore UI state
            const currentChapter = savedState.chapters.length;
            updateProgress(currentChapter + 1, savedState.story_length);
        }
    }

    function handleMessage(event) {
        try {
            const data = JSON.parse(event.data);
            
            if (data.type === 'hide_loader') {
                hideLoader();
            } else if (data.type === 'choices') {
                displayChoices(data.choices);
            } else if (data.type === 'story') {
                appendStoryText(data.content);
            } else if (data.type === 'story_complete') {
                // Check if we should show the summary button
                if (data.state && data.state.show_summary_button) {
                    displayStatsWithSummaryButton(data.state);
                } else {
                    displayStats(data.state);
                }
            } else if (data.type === 'choice_image_update') {
                // Handle image updates for choices
                updateChoiceWithImage(data.choice_index, data.image_data);
            } else if (data.type === 'chapter_image_update') {
                // Handle image updates for chapters
                updateChapterImage(data.chapter_number, data.image_data);
            } else if (data.type === 'summary_start') {
                // Clear content for summary
                document.getElementById('storyContent').innerHTML = '';
                document.getElementById('choicesContainer').innerHTML = '';
                showLoader();
            } else if (data.type === 'summary_ready') {
                // Use the state_id from the WebSocket response
                const stateId = data.state_id;
                
                // Navigate to the summary page with this state_id
                window.location.href = `/adventure/summary?state_id=${stateId}`;
            } else if (data.type === 'summary_complete') {
                // Display the complete summary
                displaySummaryComplete(data.state);
            } else if (data.type === 'adventure_created' || data.type === 'adventure_loaded') {
                // Store the adventure_id for persistence
                if (data.adventure_id) {
                    wsManager.setAdventureId(data.adventure_id);
                    console.log(`Received adventure_id: ${data.adventure_id} from server`);
                }
                // Don't hide loader here - wait for hide_loader message
            } else {
                // For any other message types, hide the loader as a fallback
                hideLoader();
            }
        } catch (e) {
            // Assume it's plain text if JSON parsing fails
            hideLoader();
            appendStoryText(event.data);
        }
    }

    // Function to update a choice with an image
    function updateChoiceWithImage(choiceIndex, imageData) {
        const choicesContainer = document.getElementById('choicesContainer');
        const choiceButtons = choicesContainer.querySelectorAll('button.choice-card');
        
        if (choiceIndex >= 0 && choiceIndex < choiceButtons.length) {
            const choiceButton = choiceButtons[choiceIndex];
            
            // Create image element if it doesn't exist
            let imageContainer = choiceButton.querySelector('.choice-image-container');
            if (!imageContainer) {
                const contentDiv = choiceButton.querySelector('.choice-content');
                
                if (!contentDiv) {
                    // If we don't have the new structure, create it
                    const oldContent = choiceButton.innerHTML;
                    choiceButton.innerHTML = '';
                    
                    const newContentDiv = document.createElement('div');
                    newContentDiv.className = 'choice-content';
                    
                    const textDiv = document.createElement('div');
                    textDiv.className = 'choice-text';
                    textDiv.innerHTML = oldContent;
                    
                    imageContainer = document.createElement('div');
                    imageContainer.className = 'choice-image-container';
                    
                    newContentDiv.appendChild(textDiv);
                    newContentDiv.appendChild(imageContainer);
                    choiceButton.appendChild(newContentDiv);
                } else {
                    // If we have the content div but no image container
                    imageContainer = document.createElement('div');
                    imageContainer.className = 'choice-image-container';
                    contentDiv.appendChild(imageContainer);
                }
            }
            
            // Add or update image
            imageContainer.innerHTML = `<img src="data:image/jpeg;base64,${imageData}" alt="Illustration of choice" class="w-full h-auto rounded-lg">`;
            imageContainer.style.display = 'block';
            
            // Add fade-in animation
            const img = imageContainer.querySelector('img');
            img.classList.add('fade-in');
            setTimeout(() => {
                img.classList.add('show');
            }, 50);
        }
    }
    
    // Function to update the chapter image
    function updateChapterImage(chapterNumber, imageData) {
        const imageContainer = document.getElementById('chapterImageContainer');
        const image = document.getElementById('chapterImage');
        
        // Set the image source
        image.src = `data:image/jpeg;base64,${imageData}`;
        image.alt = `Illustration for Chapter ${chapterNumber}`;
        
        // Show the container
        imageContainer.classList.remove('hidden');
        
        // Add fade-in animation
        image.classList.add('fade-in');
        setTimeout(() => {
            image.classList.add('show');
        }, 50);
    }

    function sendMessage(message) {
        if (storyWebSocket && storyWebSocket.readyState === WebSocket.OPEN) {
            storyWebSocket.send(JSON.stringify(message));
        } else {
            console.error('WebSocket is not open. Message not sent:', message);
        }
    }

    // --- State Management Functions ---
    function manageState(action, data) {
        switch (action) {
            case 'initialize':
                // Initialize state with selected category and lesson
                const initialState = {
                    storyCategory: data.storyCategory,
                    lessonTopic: data.lessonTopic,
                    story_length: 10, // Fixed at 10 chapters
                    current_chapter_id: 'start',
                    chapters: [],
                    selected_narrative_elements: {},
                    selected_sensory_details: {},
                    selected_theme: '',
                    selected_moral_teaching: '',
                    selected_plot_twist: '',
                    metadata: {},
                    current_storytelling_phase: 'Exposition'
                };
                stateManager.saveState(initialState);
                return initialState;

            case 'update':
                const existingState = stateManager.loadState() || {};
                const updatedState = { ...existingState, ...data };
                stateManager.saveState(updatedState);
                return updatedState;

            case 'reset':
                stateManager.clearState();
                return null;

            default:
                console.error('Unknown state action:', action);
                return null;
        }
    }

    function makeChoice(choiceId, choiceText) {
        if (storyWebSocket && storyWebSocket.readyState === WebSocket.OPEN) {
            showLoader();
            // Clear the stream buffer when making a new choice
            streamBuffer = '';
            if (renderTimeout) {
                clearTimeout(renderTimeout);
            }
            
            // Reset active paragraphs for the new chapter
            activeParagraphs.clear();

            const existingState = stateManager.loadState() || {};
            const currentChapter = existingState.chapters || [];
            
            // Create new chapter data with complete structure
            const newChapter = {
                chapter_number: currentChapter.length + 1,
                content: document.getElementById('storyContent').textContent,
                chapter_type: 'story', // This will be corrected by server if needed
                response: {
                    chosen_path: choiceId,
                    choice_text: choiceText
                },
                chapter_content: {
                    content: document.getElementById('storyContent').textContent,
                    choices: [] // Empty choices since this is a completed chapter
                }
            };

            const updatedState = manageState('update', {
                current_chapter_id: choiceId,
                chapters: [...currentChapter, newChapter]
            });

            updateProgress(updatedState.chapters.length + 1, updatedState.story_length);

            // Send state and choice data to server
            sendMessage({
                state: updatedState,
                choice: {
                    id: choiceId,
                    text: choiceText,
                    chapter_number: currentChapter.length + 1
                }
            });

            // Clear UI for next chapter
            document.getElementById('storyContent').textContent = '';
            document.getElementById('choicesContainer').innerHTML = '';
            
            // Hide the chapter image container for the new chapter
            // It will be shown again when the new image is ready
            document.getElementById('chapterImageContainer').classList.add('hidden');
        }
    }

    // Function to reset application state
    function resetApplicationState() {
        // Clear state
        manageState('reset');
        
        // Clear markdown buffer and timeout
        streamBuffer = '';
        if (renderTimeout) {
            clearTimeout(renderTimeout);
        }
        
        // Reset adventure_id
        wsManager.setAdventureId(null);
        
        // Reset active paragraphs
        activeParagraphs.clear();
        
        // Reset UI to initial state - add/remove hidden classes to trigger transitions
        document.getElementById('lessonTopicScreen').classList.add('hidden');
        document.getElementById('storyContainer').classList.add('hidden');
        document.getElementById('storyCategoryScreen').classList.remove('hidden');
        document.getElementById('introText').classList.remove('hidden');
        
        // Hide loaders
        document.getElementById('loaderOverlay').classList.remove('active');
        document.getElementById('loaderOverlay').classList.add('hidden');
        
        // Clear content
        document.getElementById('storyContent').textContent = '';
        document.getElementById('choicesContainer').innerHTML = '';
        
        // Reset progress
        updateProgress(1, '-');
        
        // Close WebSocket if it exists
        if (storyWebSocket) {
            storyWebSocket.close();
            storyWebSocket = null;
        }
        
        // Reset selections
        document.getElementById('storyCategory').value = '';
        document.getElementById('lessonTopic').value = '';
        selectedCategory = '';
        selectedLessonTopic = '';
        
        // Reset carousel selections and re-initialize the category carousel
        const cards = document.getElementsByClassName('carousel-card');
        Array.from(cards).forEach(card => {
            card.classList.remove('selected', 'selecting', 'active');
        });
        
        // Re-initialize the category carousel with our Carousel class
        window.categoryCarousel = new Carousel({
            elementId: 'categoryCarousel',
            itemCount: totalCategories,
            dataAttribute: 'category',
            inputId: 'storyCategory',
            onSelect: (categoryId) => {
                selectedCategory = categoryId;
            }
        });
        
        // Set up global keyboard navigation
        setupCarouselKeyboardNavigation([window.categoryCarousel]);
    }

// --- Event Handlers ---
// Note: startAdventure function is defined above

    // --- Initialization ---

    // Add click handler to banner for reset
    document.querySelector('h1 a').addEventListener('click', function(e) {
        e.preventDefault();
        resetApplicationState();
    });

    // On page load, check if we're continuing a story
    // window.onload = function() { // OLD CODE - REMOVE/REPLACE
    // ... existing onload logic ...
    // }; // OLD CODE - REMOVE/REPLACE

    window.addEventListener('DOMContentLoaded', async () => {
        if (!window.supabase) {
            console.error("CRITICAL: Supabase client (window.supabase) not found on DOMContentLoaded.");
            showError("Application cannot start: Auth service failed to load.");
            const storyCategoryScreen = document.getElementById('storyCategoryScreen');
            if (storyCategoryScreen) {
                storyCategoryScreen.innerHTML = '<p class="text-red-500 text-center p-8 text-lg">Application Error: Core authentication service failed. Please refresh or contact support.</p>';
            }
            hideLoader();
            return;
        }

        const authInitialized = await authManager.initialize();
        if (!authInitialized) {
            console.log("Authentication not initialized or redirecting. Halting further page script execution.");
            return;
        }

        const logoutButton = document.getElementById('logout-button');
        if (logoutButton) {
            logoutButton.addEventListener('click', () => authManager.handleLogout());
        } else {
            console.warn("Logout button not found on the page. Ensure it's added to the HTML.");
        }

        const urlParams = new URLSearchParams(window.location.search);
        const adventureIdToResumeFromQuery = urlParams.get('resume_adventure_id');

        if (adventureIdToResumeFromQuery) {
            console.log(`Resuming specific adventure ID from query param: ${adventureIdToResumeFromQuery}`);
            wsManager.adventureIdToResume = adventureIdToResumeFromQuery;
            stateManager.clearState(); // Clear any local state to ensure fresh load from server

            showLoader();
            // Setup UI for adventure in progress
            document.getElementById('storyCategoryScreen').classList.add('hidden');
            document.getElementById('lessonTopicScreen').classList.add('hidden');
            document.getElementById('introText').classList.add('hidden');
            document.getElementById('storyContainer').classList.remove('hidden');
            // Note: selectedCategory and selectedLessonTopic will be set by server state
            initWebSocket();
        } else {
            const savedState = stateManager.loadState();
            if (savedState?.chapters?.length > 0 && savedState.storyCategory && savedState.lessonTopic) {
                console.log("Resuming existing adventure from localStorage.");
                showLoader();
                updateProgress(savedState.chapters.length + 1, savedState.story_length);
                
                document.getElementById('storyCategoryScreen').classList.add('hidden');
                document.getElementById('lessonTopicScreen').classList.add('hidden');
                document.getElementById('introText').classList.add('hidden');
                document.getElementById('storyContainer').classList.remove('hidden');

                selectedCategory = savedState.storyCategory;
                selectedLessonTopic = savedState.lessonTopic;
                
                const storyCatEl = document.getElementById('storyCategory');
                const lessonTopicEl = document.getElementById('lessonTopic');
                if (storyCatEl) storyCatEl.value = selectedCategory;
                if (lessonTopicEl) lessonTopicEl.value = selectedLessonTopic;

                initWebSocket();
            } else {
                console.log("Starting new adventure selection (no resume ID or localStorage state).");
                manageState('reset');
                hideLoader();
                
                if (typeof Carousel !== 'undefined' && typeof setupCarouselKeyboardNavigation !== 'undefined') {
                    if (document.getElementById('categoryCarousel') && typeof totalCategories !== 'undefined') {
                        window.categoryCarousel = new Carousel({
                            elementId: 'categoryCarousel',
                            itemCount: totalCategories,
                            dataAttribute: 'category',
                            inputId: 'storyCategory',
                            onSelect: (categoryId) => {
                                selectedCategory = categoryId;
                            }
                        });
                        setupCarouselKeyboardNavigation([window.categoryCarousel]);
                    } else {
                         console.warn("Category carousel element or totalCategories not found. Carousel UI may not function.");
                    }
                } else {
                    console.warn("Carousel class or setupCarouselKeyboardNavigation not defined. Carousel UI may not function.");
                }
            }
        }
    });

    // Clean up WebSocket when leaving the page
    window.onbeforeunload = function() {
        if (storyWebSocket) {
            storyWebSocket.close();
        }
    };

    // --- UI Update Functions ---

    // Store active paragraph indices
    let activeParagraphs = new Set();

    // Function to add click listeners to paragraphs
    function addParagraphListeners() {
        const storyContent = document.getElementById('storyContent');
        const paragraphs = storyContent.querySelectorAll('p');
        
        paragraphs.forEach((paragraph, index) => {
            // Restore active state if this paragraph was previously active
            if (activeParagraphs.has(index)) {
                paragraph.classList.add('active');
            }
            
            // Add click listener if not already added
            if (!paragraph.hasAttribute('data-listener-added')) {
                paragraph.setAttribute('data-listener-added', 'true');
                paragraph.addEventListener('click', function() {
                    // First, remove active class from all paragraphs
                    paragraphs.forEach(p => p.classList.remove('active'));
                    
                    // Clear the active paragraphs set
                    activeParagraphs.clear();
                    
                    // Add active class to the clicked paragraph
                    this.classList.add('active');
                    
                    // Update active paragraphs set with only this paragraph
                    activeParagraphs.add(index);
                });
            }
        });
    }

    function appendStoryText(text) {
        const storyContent = document.getElementById('storyContent');
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        const decodedText = tempDiv.textContent;

        // Check if this is the first chunk of text and it starts with a dialogue verb
        // This indicates we might have lost a character name and opening quote
        if (streamBuffer === '' && /^(chirped|said|whispered|shouted|called|murmured|exclaimed|replied|asked|answered|responded)/.test(decodedText.trim())) {
            console.warn('Detected text starting with dialogue verb - possible missing character name');
            // If we're starting with a dialogue verb, it's likely we lost the character name
            // We'll log this but continue processing normally
        }

        // Special handling for dialogue text at the beginning of paragraphs
        let textToAdd = decodedText;

        // If this is the first chunk of a paragraph and it starts with a quotation mark
        // make sure we preserve it properly
        if (streamBuffer === '' && decodedText.trim().startsWith('"')) {
            console.log('Detected dialogue at paragraph start - ensuring proper formatting');
            // Ensure the quotation mark is preserved
            textToAdd = decodedText;
        }

        // Check if we're starting a new paragraph after a double newline
        if (streamBuffer.endsWith('\n\n') && decodedText.trim().startsWith('"')) {
            console.log('Detected dialogue at new paragraph - ensuring proper formatting');
            // Ensure the quotation mark is preserved for new paragraphs
            textToAdd = decodedText;
        }

        // Normalize special characters while preserving opening quotes and character names
        const normalizedText = textToAdd
            .replace(/[\u2018\u2019]/g, "'")
            .replace(/[\u201C\u201D]/g, '"')
            .replace(/\u2014/g, '--')
            .replace(/\u2013/g, '-')
            .replace(/\u2026/g, '...');

        // Add text to buffer and immediately display
        streamBuffer += normalizedText;

        try {
            // Convert the entire buffer to HTML while preserving line breaks
            const htmlContent = marked.parse(streamBuffer, {
                breaks: true,
                gfm: true
            });

            // Apply the HTML content to the story container
            storyContent.innerHTML = htmlContent;

            // Add click listeners to paragraphs
            addParagraphListeners();

            // Additional check for dialogue formatting issues
            if (streamBuffer.trim().startsWith('chirped') ||
                streamBuffer.trim().startsWith('said') ||
                streamBuffer.trim().startsWith('whispered') ||
                streamBuffer.trim().startsWith('shouted') ||
                streamBuffer.trim().startsWith('called') ||
                streamBuffer.trim().startsWith('murmured') ||
                streamBuffer.trim().startsWith('exclaimed') ||
                streamBuffer.trim().startsWith('replied') ||
                streamBuffer.trim().startsWith('asked') ||
                streamBuffer.trim().startsWith('answered') ||
                streamBuffer.trim().startsWith('responded')) {

                console.warn('Story content starts with dialogue verb - possible formatting issue');

                // We could potentially add a visual indicator here for the user
                // For example, adding a small warning icon or changing the text color
                // But for now, we'll just log the warning
            }
        } catch (error) {
            console.error('Error parsing markdown:', error);
            // Fallback to plain text if markdown parsing fails
            storyContent.textContent = streamBuffer;
        }

        // Always scroll to bottom as text streams in
        storyContent.scrollTop = storyContent.scrollHeight;
    }

    function displayChoices(choices) {
        const choicesContainer = document.getElementById('choicesContainer');
        choicesContainer.innerHTML = ''; // Clear existing choices

        if (Array.isArray(choices) && choices.length === 0) {
            const button = document.createElement('button');
            button.className = 'w-full p-6 mb-3 text-center bg-indigo-600 text-white rounded-xl hover:bg-indigo-700 transition-all duration-300 transform hover:scale-[1.02] focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 shadow-lg hover:shadow-xl backdrop-blur-sm';
            button.textContent = 'Return to Landing Page';
            button.onclick = resetApplicationState;
            choicesContainer.appendChild(button);
            return;
        }

        const shadowIntensities = [
            'shadow-lg',
            'shadow-xl',
            'shadow-2xl'
        ];

        choices.forEach((choice, index) => {
            const button = document.createElement('button');
            // Base classes for the card-like button
            const baseClasses = [
                'w-full',
                'p-6',
                'mb-4',
                'text-left',
                'rounded-xl',
                'transition-all',
                'duration-300',
                'transform',
                'hover:scale-[1.02]',
                'focus:outline-none',
                'focus:ring-2',
                'focus:ring-offset-2',
                shadowIntensities[index],
                'hover:shadow-2xl',
                'backdrop-blur-sm',
                'choice-card',
                'group'
            ];
            
            button.className = baseClasses.join(' ');
            
            // Create content wrapper with text and image areas
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'choice-content';
            
            // Create text container
            const textContainer = document.createElement('div');
            textContainer.className = 'choice-text';
            
            // Add main choice text with same font styling as narrative content
            const textElement = document.createElement('p');
            textElement.className = 'narrative-font group-hover:text-gray-900 transition-colors duration-300';
            textElement.textContent = choice.text;
            
            textContainer.appendChild(textElement);
            contentWrapper.appendChild(textContainer);
            
            // Create image container (initially empty)
            const imageContainer = document.createElement('div');
            imageContainer.className = 'choice-image-container';
            imageContainer.style.display = 'none'; // Hide until image is loaded
            contentWrapper.appendChild(imageContainer);
            
            button.appendChild(contentWrapper);

            button.onclick = (e) => {
                if (storyWebSocket?.readyState !== WebSocket.OPEN) {
                    showError('Connection lost. Please refresh the page.');
                    return;
                }

                const allButtons = choicesContainer.querySelectorAll('button');
                allButtons.forEach(btn => {
                    btn.disabled = true;
                    btn.classList.add('choice-card', 'disabled');
                });

                // Add selection effect to clicked button
                const selectedButton = e.target.closest('button');
                selectedButton.classList.add('selected');

                makeChoice(choice.id, choice.text);
            };
            
            choicesContainer.appendChild(button);
        });
    }
    
    function displayStats(state) {
        const statsHtml = `
            <div class="text-center p-4">
                <h3 class="text-lg font-semibold text-green-800 mb-2">Journey Complete!</h3>
                <div class="text-sm text-green-700">
                    <p>Total Lessons: ${state.stats.total_lessons}</p>
                    <p>Correct Answers: ${state.stats.correct_lesson_answers}</p>
                    <p>Success Rate: ${state.stats.completion_percentage}%</p>
                </div>
                <button onclick="resetApplicationState()" 
                        class="mt-4 px-6 py-3 bg-green-600 text-white rounded-md hover:bg-green-700 transition btn-hover">
                    Start New Journey
                </button>
            </div>`;
        document.getElementById('choicesContainer').innerHTML = statsHtml;
    }
    
    function displayStatsWithSummaryButton(state) {
        const statsHtml = `
            <div class="text-center p-4">
                <h3 class="text-lg font-semibold text-green-800 mb-2">Journey Complete!</h3>
                <div class="text-sm text-green-700">
                    <p>Total Lessons: ${state.stats.total_lessons}</p>
                    <p>Correct Answers: ${state.stats.correct_lesson_answers}</p>
                    <p>Success Rate: ${state.stats.completion_percentage}%</p>
                </div>
                <div class="flex flex-col gap-3 mt-4">
                    <button onclick="viewAdventureSummary()" 
                           class="px-6 py-3 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition btn-hover inline-block text-center">
                        <span class="text-lg text-center">ðŸ”® Take a Trip Down ðŸ”®<br>Memory Lane</span>
                        <p class="text-sm opacity-80 mt-1">Relive your adventure and learning highlights</p>
                    </button>
                    <button onclick="resetApplicationState()" 
                            class="mt-2 px-6 py-3 bg-green-600 text-white rounded-md hover:bg-green-700 transition btn-hover text-center">
                        ðŸš€ Start New Journey
                    </button>
                </div>
            </div>`;
        document.getElementById('choicesContainer').innerHTML = statsHtml;
    }
    
    // Function to handle viewing the adventure summary
    async function viewAdventureSummary() {
        // Show loading indicator
        showLoader();
        
        // Set a timeout for WebSocket response
        let timeoutId = setTimeout(() => {
            console.log('WebSocket response timeout, falling back to REST API');
            fallbackToRestApi();
        }, 5000); // 5 seconds timeout
        
        // Flag to track if we've already redirected
        let hasRedirected = false;
        
        // Store the original onmessage handler
        const originalOnMessage = storyWebSocket.onmessage;
        
        // Override the onmessage handler to catch the summary_ready message
        storyWebSocket.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                
                if (data.type === 'summary_ready') {
                    // Clear the timeout
                    clearTimeout(timeoutId);
                    
                    // Use the state_id from the WebSocket response
                    const stateId = data.state_id;
                    
                    // Prevent duplicate redirects
                    if (!hasRedirected) {
                        hasRedirected = true;
                        
                        // Log the state ID for debugging
                        console.log('Adventure summary state ID (WebSocket):', stateId);
                        
                        // Navigate to the summary page with this state_id
                        window.location.href = `/adventure/summary?state_id=${stateId}`;
                    }
                } else {
                    // Pass other messages to the original handler
                    if (originalOnMessage) {
                        originalOnMessage(event);
                    }
                }
            } catch (e) {
                // If JSON parsing fails, pass to original handler
                if (originalOnMessage) {
                    originalOnMessage(event);
                }
            }
        };
        
        // Send reveal_summary message via WebSocket
        if (storyWebSocket && storyWebSocket.readyState === WebSocket.OPEN) {
            console.log('Sending reveal_summary message via WebSocket');
            // Get the current state
            const currentState = stateManager.loadState();
            
            if (!currentState) {
                showError('No adventure state found. Please complete an adventure first.');
                hideLoader();
                return;
            }
            
            // Send both state and choice
            storyWebSocket.send(JSON.stringify({
                state: currentState,
                choice: "reveal_summary"
            }));
        } else {
            // Fallback if WebSocket is not available
            console.log('WebSocket not available, falling back to REST API');
            clearTimeout(timeoutId);
            fallbackToRestApi();
        }
        
        // Fallback function to use REST API
        async function fallbackToRestApi() {
            try {
                console.log('Using REST API fallback for adventure summary');
                
                // Prevent duplicate redirects
                if (hasRedirected) return;
                
                // Get the current state from localStorage
                const currentState = stateManager.loadState();
                
                if (!currentState) {
                    showError('No adventure state found. Please complete an adventure first.');
                    hideLoader();
                    return;
                }
                
                // Get the adventure_id if available
                const adventureId = wsManager.getAdventureId();
                
                // First store the state via REST API
                const url = new URL('/adventure/api/store-adventure-state', window.location.origin);
                if (adventureId) {
                    url.searchParams.append('adventure_id', adventureId);
                }
                
                const response = await fetch(url.toString(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(currentState),
                });
                
                if (!response.ok) {
                    throw new Error('Failed to store adventure state');
                }
                
                const data = await response.json();
                const stateId = data.state_id;
                
                // Log the state ID for debugging
                console.log('Adventure summary state ID (REST API):', stateId);
                
                // Prevent duplicate redirects
                if (hasRedirected) return;
                hasRedirected = true;
                
                // Create a clean URL with a single state_id parameter
                const summaryUrl = new URL('/adventure/summary', window.location.origin);
                summaryUrl.searchParams.append('state_id', stateId);
                
                // Navigate to the summary page with the state ID
                window.location.href = summaryUrl.toString();
            } catch (error) {
                console.error('Error in fallback:', error);
                showError('Failed to load adventure summary. Please try again.');
                hideLoader();
            }
        }
    }
    
    
    function displaySummaryComplete(state) {
        hideLoader();
        
        // Update chapter number to show we're in the summary
        updateProgress(state.current_chapter.chapter_number, state.stats.total_lessons);
        
        // Add buttons at the bottom
        const buttonsHtml = `
            <div class="text-center p-4">
                <div class="flex flex-col gap-3 mt-4">
                    <button onclick="viewAdventureSummary()" 
                           class="px-6 py-3 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition btn-hover inline-block text-center">
                        <span class="text-lg text-center">ðŸ”® Take a Trip Down ðŸ”®<br>Memory Lane</span>
                        <p class="text-sm opacity-80 mt-1">Relive your adventure and learning highlights</p>
                    </button>
                    <button onclick="resetApplicationState()" 
                            class="mt-2 px-6 py-3 bg-green-600 text-white rounded-md hover:bg-green-700 transition btn-hover text-center">
                        ðŸš€ Start New Journey
                    </button>
                </div>
            </div>`;
        document.getElementById('choicesContainer').innerHTML = buttonsHtml;
    }
</script>
