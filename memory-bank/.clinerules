# Cline Rules for Learning Odyssey

## Core Concepts

### Naming Conventions
1. Chapter: Unit of progression in ChapterType enum (LESSON, STORY, or CONCLUSION)
   - LESSON: Educational content from lessons.csv with LLM narrative wrapper
   - STORY: Fully LLM-generated narrative content with choices
   - CONCLUSION: Final chapter with no choices, providing story resolution
2. State: Complete application state in AdventureState class
3. Adventure: Overall user journey tracked in AdventureState

### File Organization (`app/`)
1. Core application code:
   - State management: `models/story.py`
   - LLM integration: `services/llm/`
   - WebSocket components:
     * Routing: `routers/websocket_router.py`
     * Business logic: `services/websocket_service.py`
   - Chapter management: `services/chapter_manager.py`
2. Content sources:
   - Lesson database: `data/lessons.csv`
   - Story templates: `data/stories.yaml`
3. Tests: `tests/` directory
   - Story simulations: `tests/simulations/story_simulation.py`

### Critical Implementation Rules
1. State Management:
   - AdventureState MUST be single source of truth
   - NEVER hardcode chapter numbers (app logic may change)
   - Use planned_chapter_types for chapter progression
   - Base logic on state properties, not assumptions
   - Complete state serialization required
   - Dynamic story length via state.story_length
   - Type hints required for all state properties
   - State changes must be logged

2. Chapter Requirements:
   - First two chapters MUST be STORY type (for setting/character development)
   - Second-to-last chapter MUST be STORY type (for pivotal choices)
   - Last chapter MUST be CONCLUSION type (for story resolution)
   - 50% of remaining chapters MUST be LESSON type (subject to available questions)
   - No question repetition in session
   - Answer options MUST be shuffled
   - Immediate feedback required
   - Error recovery for failed state updates

3. Documentation Requirements:
   - Type hints required for all functions
   - Docstrings mandatory for all classes/functions
   - Complex logic must be commented
   - Error handling must be documented
   - State changes must be logged

## Development Workflow

### Code Changes
1. Question sampling changes need tests
2. Answer shuffling requires validation
3. State changes need synchronization
4. WebSocket changes need connection tests

### Testing Requirements
1. Run story simulation on changes to:
   - app/services/llm/*
   - app/routers/websocket_router.py
   - app/services/websocket_service.py
   - app/services/chapter_manager.py
   - app/models/story.py
   - app/init_data.py
   - app/data/stories.yaml
   - app/data/lessons.csv

### Note: 2025-02-18
   - Story simulations should be run due to recent changes:
     * New chapter logic implementation (CONCLUSION type, updated sequencing)
     * Fixed random.sample error in chapter_manager.py when no questions available
     * Updated UI to handle CONCLUSION chapters
     * Enhanced prompt engineering for CONCLUSION narrative

### Debugging Process
1. Verify question sampling
2. Check answer shuffling
3. Validate state updates
4. Analyze error cases

## Critical Paths

### Question Flow Debugging
1. Verify topic selection
2. Check sampling logic
3. Confirm shuffle implementation
4. Validate answer tracking
5. Verify question persistence
6. Test response creation
7. Check state consistency
8. Monitor error handling

### State Validation
1. Check question history
2. Verify answer selections
3. Validate chapter types
4. Confirm state transitions
5. Test question persistence
6. Verify response handling
7. Check error recovery
8. Monitor state consistency

### Response Chain
1. Verify question format
2. Check answer order
3. Validate feedback
4. Confirm state updates
5. Test question handling
6. Verify response creation
7. Check error handling
8. Monitor state consistency

### Prompt Debugging
1. Verify State Passing:
   - Check what properties are available in state
   - Confirm they're being passed to prompt builder
   - Verify they appear in final prompt
2. Check Data Flow:
   - Trace data from state to prompt
   - Look for optional parameters
   - Verify history inclusion
3. Analyze Prompt Content:
   - Review complete prompt output
   - Check for missing context
   - Verify continuity elements

## Error Handling

### Question Errors
1. Handle sampling failures
2. Manage shuffle errors
3. Track invalid answers
4. Log question issues
5. Handle missing questions
6. Recover from errors
7. Maintain state consistency
8. Log error details

### State Errors
1. Handle synchronization failures
2. Implement recovery mechanisms
3. Maintain error boundaries
4. Log state transitions
5. Handle question errors
6. Recover from failures
7. Ensure data consistency
8. Monitor error patterns

### WebSocket Errors
1. Router-Level Errors:
   - Handle connection drops
   - Manage reconnection attempts
   - Log connection lifecycle events
   - Validate incoming messages
   - Coordinate error recovery with service
   - Monitor connection health
   - Handle client disconnects gracefully
   - Maintain connection state

2. Service-Level Errors:
   - Handle content generation failures
   - Manage state transitions
   - Process choice errors
   - Handle streaming issues
   - Validate message formats
   - Provide fallback responses
   - Maintain data consistency
   - Monitor processing health

3. Cross-Component Errors:
   - Coordinate error recovery
   - Maintain state synchronization
   - Handle timing issues
   - Log error chains
   - Implement retry strategies
   - Ensure message ordering
   - Preserve transaction integrity
   - Monitor system boundaries

### Prompt Errors
1. Log complete prompt content
2. Track missing state data
3. Monitor continuity breaks
4. Validate data flow
5. Handle question errors
6. Recover from failures
7. Ensure consistency
8. Monitor error patterns

## Testing Strategy

### Question Testing
1. Verify sampling logic
2. Test shuffle algorithm
3. Validate answer tracking
4. Check duplicate prevention
5. Test question persistence
6. Verify response creation
7. Check error handling
8. Monitor state consistency

### State Testing
1. Verify synchronization
2. Test recovery mechanisms
3. Validate error handling
4. Check performance
5. Test question handling
6. Verify response creation
7. Check state consistency
8. Monitor error patterns

### Integration Testing
1. Test full user flow
2. Verify question cycles
3. Validate answer interactions
4. Check state consistency
5. Test question handling
6. Verify response creation
7. Check error recovery
8. Monitor system health

### Prompt Testing
1. Verify state inclusion
2. Test history passing
3. Validate continuity
4. Check data flow
5. Test question handling
6. Verify response creation
7. Check error handling
8. Monitor consistency

## Documentation Standards

### Code Documentation
1. Type hints required
2. Function docstrings mandatory
3. Complex logic needs comments
4. State changes must be logged
5. Question handling documented
6. Response creation explained
7. Error handling detailed
8. State flow documented

### System Documentation
1. Question flow documentation
2. State management flows
3. Testing procedures
4. Error handling strategies
5. Question handling patterns
6. Response creation flows
7. State consistency rules
8. Error recovery procedures

### Prompt Documentation
1. Document required state
2. List critical data points
3. Explain continuity requirements
4. Detail debugging steps
5. Document question handling
6. Explain response creation
7. Detail error handling
8. Describe state management
